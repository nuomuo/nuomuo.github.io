<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>罗翔语录摘抄</title>
    <url>/read/20200208-%E7%BD%97%E7%BF%94%E8%AF%AD%E5%BD%95%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<p><strong>1、人生要做你该做的事情并接受事与愿违</strong></p>
<p>人要接受自己的有限性</p>
<p>如果你相信，天道酬勤，我命由我不由天，当然，他会给你打上一针强心针，让你去努力。但最终努力的结果，成功或者失败，如果失败了你就会陷入虚无之中，你会觉得一切的理想都是骗人的，为什么我这么努力，天道就酬勤呢？为什么我不能改变命运呢？理想主义最后就会变成虚无主义，就会变成犬儒主义，就会变成放纵主义。</p>
<span id="more"></span>

<p>当然还有一种人是宿命主义，一切都是命中注定的，不需要去做，你命中注定就能上北大，我已经给你算了八字，你看这八字跟北大的北一摸一样，你一定能上北大。最后你肯定上不了。</p>
<p>什么意思呢？做你该做的事情并接受它的事与愿违。</p>
<p>我们需要努力，也与依然是竹篮打水一场空，如果不努力，那就一定是竹篮打水一场空。</p>
<p><strong>2、人为什么害怕独处</strong></p>
<p>为什么害怕独处，因为人在独处的时候，总是会听到心灵深处的声音，这个心灵深处的声音会不断的逼问你，你这一生到底想干嘛，你怎样活着才是有意义的，当这个声音不断逼问你的时候，你会觉得烦躁，你就会觉得焦虑，因为你耳边始终有这种声音，所以你会堵住耳朵，你说别说了，当这个声音沉静的时候，你会感到空虚，会感到迷茫，所以当你独处的时候，你始终是在焦虑迷茫空虚中，周而复始。</p>
<p>那大部分的人就会选择拒绝倾听你心灵深处的追问，于是就会选择用忙碌来对抗这种事，娱乐，工作，放纵，不断的忙碌，来对抗自己心灵深处的追问，那只有当你真正的能够回答你心灵深处的那种追问，你才能够享受这种独处，你猜能够享受这种安静，但这是很难的。</p>
]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>Read</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-缓存穿透、击穿、雪崩</title>
    <url>/tech/redis/20200625-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E5%87%BB%E7%A9%BF-%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>缓存雪崩：大面积 key 过期导致大量请求直接打到 db，db挂了。解决：设置过期时间加随机时间 </li>
<li>缓存穿透：就是要查询的东西，redis 和数据库都没有，那么这样的请求一样是直接打到 db 了，量上来，一样要挂。解决：要做好入仓检查 </li>
<li>缓存击穿：热点缓存的 key 突然失效了，也会导致大量请求直接打到db，那么将 ke y的时间设置长一点或者设为永久。 最主要的是：设置熔断器，保底。即限流。</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就会造成缓存雪崩。</p>
<p><strong>举个简单的例子</strong>：目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。</p>
<p>如果所有首页的 Key 失效时间都是 12 小时，中午 12 点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的 Key 都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能 DBA 都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>尽量让失效的时间点不分布在同一个时间点</p>
<p>在批量往<strong>Redis</strong>存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setRedis(Key,value，time + Math.random() * 10000)</span><br></pre></td></tr></table></figure>

<p>如果<strong>Redis</strong>是集群部署，将热点数据均匀分布在不同的 <strong>Redis</strong> 库中也能避免全部失效的问题，不过本人在生产环境中操作集群的时候，单个服务都是对应的单个<strong>Redis</strong> 分片，是为了方便数据的管理，但是也同样有了可能会失效这样的弊端，失效时间随机是个好策略。</p>
<p>或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是 1 开始自增上去的，如发起为 id 值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p>
<p><img src="../../../images/post/tech/redis/20200625/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png"></p>
<p><strong>如上图所示，如果不对参数做校验，数据库 id 都是大于0的，我一直用小于 0 的参数去请求你，每次都能绕开Redis 直接打到数据库，数据库也查不到，每次都这样，并发高点就容易崩掉了。</strong></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>缓存穿透</strong>：</p>
<p>方法—：在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码 Return，比如：id 做基础校验，id &lt;=0 的直接拦截等。</p>
<blockquote>
<p>这里我想提的一点就是，我们在开发程序的时候都要有一颗不信任的心，就是不要相信任何调用方，比如你提供了API接口出去，你有这几个参数，那我觉得作为被调用方，任何可能的参数情况都应该被考虑到，做校验，因为你不相信调用你的人，你不知道他会传什么参数给你。</p>
<p>举个简单的例子，你这个接口是分页查询的，但是你没对分页参数的大小做限制，调用的人万一一口气查 Integer.MAX_VALUE 一次请求就要你几秒，多几个并发你不就挂了么？是公司同事调用还好大不了发现了改掉，但是如果是黑客或者竞争对手呢？在你双十一当天就调你这个接口会发生什么，就不用我说了吧。这是之前的Leader 跟我说的，我觉得大家也都应该了解下。</p>
</blockquote>
<p>方法二：从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应 Key 的 Value 写为null，将空对象也缓存起来，并给它设置一个很短的过期时间，最长不超过5分钟（设置太长会导致正常情况也没法使用）。</p>
<blockquote>
<p>这样可以防止攻击用户反复用同一个id暴力攻击，但是我们要知道正常用户是不会在单秒内发起这么多次请求的，那网关层 <strong>Nginx</strong> 有配置项，可以让运维对单个IP每秒访问次数超出阈值的IP都拉黑。</p>
</blockquote>
<p>方法三：<strong>Redis</strong>还有一个高级用法布隆过滤器（Bloom Filter)这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在 return 就好了，存在你就去查了 DB 刷新 KV 再 return。采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</p>
<hr>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>至于<strong>缓存击穿</strong>嘛，这个跟<strong>缓存雪崩</strong>有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是<strong>缓存击穿</strong>是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>缓存击穿</strong>的话，设置热点数据永远不过期。</p>
<p>或者加上互斥锁就能搞定了</p>
<hr>
<h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><p>一般避免以上情况发生我们从三个时间段去分析下：</p>
<ul>
<li>事前：<strong>Redis</strong> 高可用，主从+哨兵，<strong>Redis cluster</strong>，避免全盘崩溃。</li>
<li>事中：本地 <strong>ehcache</strong> 缓存 + <strong>Hystrix</strong> 限流+降级，避免 MySQL 被打死。</li>
<li>事后：<strong>Redis</strong> 持久化 <strong>RDB</strong>+<strong>AOF</strong>，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p>
<p><strong>好处：</strong></p>
<p>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。 只要数据库不死，就是说，对用户来说，3/5 的请求都是可以被处理的。 只要有 3/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</p>
<p>某明星爆出什么事情，你发现你去微博怎么刷都空白界面，但是有的人又直接进了，你多刷几次也出来了，那是做了降级，牺牲部分用户的体验换来服务的安全</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-数据持久化</title>
    <url>/tech/redis/20220626-Redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>Redis 工作时数据都存储在内存中，万一服务器断电，则所有数据都会丢失。针对这种情况，Redis采用持久化机制来增强数据安全性。<br>Redis是怎么进行持久化的？</p>
</blockquote>
<span id="more"></span>
<p>持久化是有两种方式：<br><strong>RDB：</strong>RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。<br><strong>AOF：</strong>AOF 机制根据配置文件中指定的策略，把生成数据的命令以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的 binlog。<br>两种方式都可以把Redis内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，RDB更适合做冷备，AOF更适合做热备。</p>
<p>两种机制全部开启的时候，Redis 在重启的时候会默认使用 AOF 去重新构建数据，因为 AOF 的数据是比 RDB更完整的。</p>
<p>RDB 做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p>这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息</p>
<h3 id="RDB的原理是什么？"><a href="#RDB的原理是什么？" class="headerlink" title="RDB的原理是什么？"></a>RDB的原理是什么？</h3><p>fork 和 cow。fork 是指 redis 通过创建子进程来进行 RDB 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<h3 id="两种机制各自优缺点是啥？"><a href="#两种机制各自优缺点是啥？" class="headerlink" title="两种机制各自优缺点是啥？"></a>两种机制各自优缺点是啥？</h3><p>我先说RDB吧</p>
<h4 id="RDB优点："><a href="#RDB优点：" class="headerlink" title="RDB优点："></a>RDB优点：</h4><p>他会生成多个数据文件，每个数据文件分别都代表了某一时刻 Redis 里面的数据，这种方式，有没有觉得很适合做冷备，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。</p>
<p>RDB对 Redis 的性能影响非常小，是因为在同步数据的时候他只是 fork 了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快。</p>
<h4 id="RDB缺点："><a href="#RDB缺点：" class="headerlink" title="RDB缺点："></a>RDB缺点：</h4><p>RDB 都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF 则最多丢一秒的数据，数据完整性 上高下立判。</p>
<p>还有就是 RDB 在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候 fork 了一个子进程去生成一个大快照，就会出大问题。</p>
<p>再来说说AOF</p>
<h4 id="AOF优点："><a href="#AOF优点：" class="headerlink" title="AOF优点："></a>AOF优点：</h4><p>上面提到了，RDB五分钟一次生成快照，但是AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。</p>
<p>AOF在对日志文件进行操作的时候是以append-only的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。</p>
<p>AOF的日志是通过一个叫非常可读的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了，比如公司的实习生通过flushall清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份AOF日志文件，把最后一条flushall命令删了就完事了。</p>
<h4 id="AOF缺点："><a href="#AOF缺点：" class="headerlink" title="AOF缺点："></a>AOF缺点：</h4><p>一样的数据，AOF文件比RDB还要大。</p>
<p>AOF 开启后，Redis 支持写的 QPS 会比 RDB 支持写的要低，他不是每秒都要去异步刷新一次日志嘛 fsync，当然即使这样性能还是很高，我记得 ElasticSearch 也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的。</p>
<h3 id="那两者怎么选择？"><a href="#那两者怎么选择？" class="headerlink" title="那两者怎么选择？"></a>那两者怎么选择？</h3><p>我全都要，你单独用RDB你会丢失很多数据，你单独用AOF，你数据恢复没RDB来的快，真出什么时候第一时间用RDB恢复，然后AOF做数据补全，真香！冷备热备一起上，才是互联网时代一个高健壮性系统的王道。</p>
<p>持久化时如果突然机器掉电会怎样？<br>取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync，比如 1次/1s，这个时候最多就会丢失 1s的数据。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
